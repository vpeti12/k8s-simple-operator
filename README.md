# k8s-simple-operator
 A simple Kubernetes operator for deploying basic application (e.g. *nginx*,
 *httpd*) configurable using Kubernetes [Custom Resource](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/).

## Description
The purpose of this project is to demonstrate a simple [Kubernetes Operator](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/)
generated by [Kubebuilder](https://github.com/kubernetes-sigs/kubebuilder).
The [Controller](https://kubernetes.io/docs/concepts/architecture/controller/)
logic handles the Reconciliation phase and aligns the Custom Resource changes
within the cluster. The selected application (e.g. *nginx*) is running in a Pod
started by a Deployment with a connecting Service and Ingress to forward the
traffic. [NGINX Ingress Controller](https://kubernetes.github.io/ingress-nginx/)
manages the Ingress resource to publish the application.
The solution support **https access** with self-signed TLS certificate using
[cert-manager](https://cert-manager.io/).

## Getting Started
The operator can be run on any Kubernetes cluster, but there are some
prerequisites that has to be installed before deployment.

For local testing, you can use [KIND](https://sigs.k8s.io/kind) and the steps
mentioned in section [Running on the cluster](#running-on-the-cluster).

The easiest way of deploying `k8s-simple-operator` is to use the published
image, so you can skip to [`Packages`](#packages) if only interested in that.

### Prerequisites
The Kubernetes cluster should have the following components installed:

#### ingress-nginx
An Ingress Controller (paired with an Ingress resource) is needed to provide
external access (HTTP and HTTPS) to the cluster Services (see [kubernetes documentation](https://kubernetes.io/docs/concepts/services-networking/ingress/)
for further details).

See the NGINX Ingress Controller [installation guide](https://kubernetes.github.io/ingress-nginx/deploy/)
or simply run:
```sh
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml
```

#### cert-manager
The solution uses the [Automated Certificate Management](https://kubernetes.github.io/ingress-nginx/user-guide/tls/#automated-certificate-management-with-cert-manager) of NGINX Ingress
controller with `cert-manager` to setup HTTPS access to the specified host
(domain) with **self-signed** TLS certificate.

This solution is good for a local cluster (e.g. *kind*) if cloud provider with
public DNS entry is not available (hence solutions like Let's Encrypt can't be
used as domain is local).

See the [installation instructions](https://cert-manager.io/docs/installation/)
or simply run:
```sh
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.11.0/cert-manager.yaml
```

### Configuration
You can configure the Deployment using a Custom Resource. There are 3
parameters to customize the operator:

- **image** : the container image (and tag) of the application you would like run
- **replicas** : number of replicas of the deployed pods
- **host** : host where the application is accessible (i.e. in the browser)

There is a sample instance of the Custom Resource `SimpleApp` under
`config/samples/`:
```yaml
[...]
spec:
  image: "nginx:latest"
  replicas: 1
  host: "helloworld.localdev.me"
```

### Running on the cluster
For testing purposes, you can run the operator on local cluster (*kind*).

1. Install the CRDs into the cluster:

```sh
make install
```

2. Run your controller (this will run in the foreground, so switch to a new
terminal if you want to leave it running):

```sh
make run
```

3. Install Instances of the Custom Resource `SimpleApp`:

```sh
kubectl apply -f config/samples/myapp_v1alpha1_simpleapp.yaml
```

**NOTE:** Reapply the config after any changes to the resource in order to
take effect.

### Uninstall CRDs
To delete the CRDs from the cluster:

```sh
make uninstall
```

### Deployment
You can build and push the image yourself or use the available packages for
deployment mentioned [below](#packages).

1. Build and push your image to the location specified by `IMG`:

```sh
make docker-build docker-push IMG=<some-registry>/k8s-simple-operator:tag
```

2. Deploy the controller to the cluster with the image specified by `IMG`:

```sh
make deploy IMG=<some-registry>/k8s-simple-operator:tag
```

3. Install Instances of the Custom Resource `SimpleApp`:

```sh
kubectl apply -f config/samples/myapp_v1alpha1_simpleapp.yaml
```

**NOTE:** UnDeploy the controller from the cluster:
```sh
make undeploy
```

#### Packages

You can quicly deploy `k8s-simple-operator` on a cluster by using the available
packages:

https://github.com/vpeti12/k8s-simple-operator/pkgs/container/k8s-simple-operator

Simply run

```sh
make deploy IMG=ghcr.io/vpeti12/k8s-simple-operator:latest
```

**NOTE:** Keep in mind that you need the prerequisites installed and after
deploying, apply a `SimpleApp` Custom Resource Instance, e.g.:
```sh
kubectl apply -f config/samples/myapp_v1alpha1_simpleapp.yaml
```

### Testing
You can check if the solution works by accessing the domain specified in the
host parameter (e.g. *helloworld.localdev.me*) in the browser. Keep in mind
that the solution works with self-signed certificate, so the browser will give
a warning about the certificate.

## Improvement areas
- Support [Let's Encrypt](https://letsencrypt.org/) certificate validation in
case of a public DNS host. The solution could be aligned in case the operator
is running on a public cloud provider.

- Improve CI with testing.

- Refactoring of the code (especially the Reconciliation business logic) and
the GitHub Actions CI.