# k8s-simple-operator
 A simple Kubernetes operator for deploying basic application (e.g. *nginx*,
 *httpd*) configurable using Kubernetes Custom Resource.

## Description
The purpose of this project is to demonstrate a simple [Kubernetes Operator](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/)
generated by [Kubebuilder](https://github.com/kubernetes-sigs/kubebuilder).
The [Controller](https://kubernetes.io/docs/concepts/architecture/controller/)
logic handles the Reconciliation phase and aligns the Custom Resource changes.
The selected application (e.g. *nginx*) is running in a Pod as part of a
Deployment with a connecting Service and Ingress to forward the traffic.
[NGINX INgress Controller](https://kubernetes.github.io/ingress-nginx/) manages
the Ingress resource to publish the application.
The solution support **https access** with self-signed TLS certificate using
[cert-manager](https://cert-manager.io/).

See below hwo to deploy and configure the application using the operator.

## Getting Started
The operator can be run on any Kubernetes cluster, but there are some
prerequisites.

For local testing, you can use [KIND](https://sigs.k8s.io/kind).

### Prerequisites
The Kubernetes cluster should have the following components installed:

#### ingress-nginx
An Ingress Controller (paired with an Ingress resource) is needed to provide
external access (HTTP and HTTPS) to the cluster Services (see [kubernetes documentation](https://kubernetes.io/docs/concepts/services-networking/ingress/)
for further details).

See the [install instructions](https://kubernetes.github.io/ingress-nginx/deploy/)
or simply run:
```sh
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml
```

#### cert-manager
The solution uses the [Automated Certificate Management](https://kubernetes.github.io/ingress-nginx/user-guide/tls/#automated-certificate-management-with-cert-manager) of NGINX Ingress
controller with `cert-manager` to setup HTTPS access to the specified host
(domain) with **self-signed** TLS certificate.

This solution is good for a local cluster (e.g. kind) if cloud provider with
public DNS entry is not available (hence solutions like Let's Encrypt can't be
used).

See the [install instructions](https://cert-manager.io/docs/installation/)
or simply run:
```sh
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.11.0/cert-manager.yaml
```

### Configuration
You can configure the Deployment using a Custom Resource. There are 3
parameters to customize the operator:

- **image** : the container image (and tag) of the application you would like run
- **replicas** : number of replicas of the deployed pods
- **host** : host where the application is accessible (ie. in the browser)

There is a sample instance of the Custom Resource `SimpleApp` under
`config/samples/`:
```yaml
[...]
spec:
  image: "nginx:latest"
  replicas: 1
  host: "helloworld.localdev.me"
```

### Running on the cluster
1. Install the CRDs into the cluster:

```sh
make install
```

2. Run your controller (this will run in the foreground, so switch to a new
terminal if you want to leave it running):

```sh
make run
```

3. Install Instances of the Custom Resource `SimpleApp`:

```sh
kubectl apply -f config/samples/myapp_v1alpha1_simpleapp.yaml
```

**NOTE:** Reapply the config after any changes to the resource in order to
take effect.

### Deployment

1. Build and push your image to the location specified by `IMG`:

```sh
make docker-build docker-push IMG=<some-registry>/k8s-simple-operator:tag
```

2. Deploy the controller to the cluster with the image specified by `IMG`:

```sh
make deploy IMG=<some-registry>/k8s-simple-operator:tag
```

**NOTE:** UnDeploy the controller from the cluster:
```sh
make undeploy
```

### Uninstall CRDs
To delete the CRDs from the cluster:

```sh
make uninstall
```

### Testing
You can check if the solution works by accessing the domain specified in the
host parameter (e.g. *helloworld.localdev.me*) in the browser. Keep in mind
that the solution works with self-signed cerificate, so the browser will give
a warning about the certificate.

## Improvement ideas
- Support [Let's Encrypt](https://letsencrypt.org/) certificate validation in
case of a public DNS host. The solution could be aligned in case the operator
is running on a public cloud provider.

- Improve CI with additional testing.

- Refactoring of the code and the GitHub Actions CI.

## License

Copyright 2023 vpeti12.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
